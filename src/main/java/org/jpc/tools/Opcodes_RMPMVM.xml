<?xml version="1.0"?>
<?xml-stylesheet href="x86optable.xsl" type="text/xsl"?>
<opcodesnippets>
<!--  <opcode mnemonic="UnimplementedOpcode" mem="false">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        if (true) throw new IllegalStateException("Unimplemented opcode");</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="InvalidOpcode" mem="false">
    <return>Branch.Jmp_Unknown</return>
    <snippet>        if (true) throw new IllegalStateException("Invalid opcode");</snippet>
    <args size="0"></args>
  </opcode>-->

  <opcode mnemonic="bsf">
    <return>Branch.None</return>
    <snippet>        if ($op2.get == 0) {
	    cpu.zf(true);
	} else {
	    cpu.zf(false);
            cpu.of = cpu.af = cpu.cf = false;
            cpu.flagStatus = SP;
            cpu.flagResult = StaticOpcodes.numberOfTrailingZeros($op2.get);
	    $op1.setcpu.flagResult);
	}</snippet>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>

  <opcode mnemonic="bt" mem="false">
    <return>Branch.None</return>
    <snippet>        cpu.zf(cpu.zf());
        cpu.cf((($op1.get &amp; (1 &lt;&lt; ($op2.get &amp; ($size-1)))) != 0));</snippet>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
  </opcode>
  <opcode mnemonic="bt" mem="true">
    <return>Branch.None</return>
    <snippet>        cpu.zf(cpu.zf());
        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        int offset = (($op2.get &amp; ~($size-1))/8);
        cpu.cf((($op1.getA offset) &amp; bit) != 0));</snippet>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
  </opcode>

  <opcode mnemonic="btc" mem="false">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        cpu.cf = (0 != ($op1.get &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.set$cast($op1.get^bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Gd</args>
  </opcode>
  <opcode mnemonic="btc" mem="true">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        int offset = (($op2.get &amp; ~($size-1))/8);
        cpu.cf = (0 != ($op1.getA offset) &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.setA offset, $cast($op1.getA offset)^bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="btr" mem="false">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        cpu.cf = (0 != ($op1.get &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.set$cast($op1.get &amp; ~bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>
  <opcode mnemonic="btr" mem="true">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        int offset = (($op2.get &amp; ~($size-1))/8);
        cpu.cf = (0 != ($op1.getA offset) &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.setA offset, $cast($op1.getA offset) &amp; ~bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="bts" mem="false">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        cpu.cf = (0 != ($op1.get &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.set$cast($op1.get | bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>
  <opcode mnemonic="bts" mem="true">
    <return>Branch.None</return>
    <snippet>        int bit = 1 &lt;&lt; ($op2.get &amp; ($size-1));
        int offset = (($op2.get &amp; ~($size-1))/8);
        cpu.cf = (0 != ($op1.getA offset) &amp; bit));
        cpu.flagStatus &amp;= NCF;
        $op1.setA offset, $cast($op1.getA offset) | bit));</snippet>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
  </opcode>

  <opcode mnemonic="cbw">
    <return>Branch.None</return>
    <snippet>            cpu.r_ax.set16((byte)cpu.r_al.get8());</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cdq">
    <return>Branch.None</return>
    <snippet>        if (cpu.r_eax.get32() &lt; 0)
            cpu.r_edx.set32(-1);
        else
            cpu.r_edx.set32(0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cmc">
    <return>Branch.None</return>
    <snippet>        cpu.cf = cpu.cf() ^ true;
        cpu.flagStatus &amp;= NCF;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="daa">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.daa(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="das">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.das(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="div">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        int ldiv = 0xffff &amp; cpu.r_ax.get16();
        short quot16 = (short)(ldiv / ($mask $op1.get));
        if (quot16 != (quot16 &amp; 0xff))
            throw ProcessorException.DIVIDE_ERROR;
        cpu.r_al.set$size($cast quot16);
        cpu.r_ah.set$size($cast (ldiv % ($mask $op1.get)));</snippet>
    <args size="8">Eb</args>
  </opcode>

  <opcode mnemonic="div">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        long ldiv = ((0xffffL &amp; cpu.r_edx.get16()) &lt;&lt; 16 ) | ($mask cpu.r_eax.get16());
        int quot32 = (int)(ldiv / ($mask $op1.get));
        if (quot32 != (quot32 &amp; 0xffff))
            throw ProcessorException.DIVIDE_ERROR;
        cpu.r_eax.set$size($cast quot32);
        cpu.r_edx.set$size($cast (ldiv % ($mask $op1.get)));</snippet>
    <args size="16">Ew</args>
  </opcode>
  <opcode mnemonic="div">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        long ldiv = ((0xffffffffL &amp; cpu.r_edx.get32()) &lt;&lt; 32 ) | (0xffffffffL &amp; cpu.r_eax.get32());
        long quot64 = ldiv / (0xffffffffL &amp; $op1.get);
        if (quot64 != (quot64 &amp; 0xffffffffL))
            throw ProcessorException.DIVIDE_ERROR;
        cpu.r_eax.set$size($cast quot64);
        cpu.r_edx.set$size($cast (ldiv % (0xffffffffL &amp; $op1.get)));</snippet>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="idiv">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        short ldiv = (short)cpu.r_ax.get16();
        short quot16 = (short)(ldiv / $op1.get);
        if (quot16 != (byte) quot16)
            throw ProcessorException.DIVIDE_ERROR;
        cpu.r_al.set$size((byte)quot16);
        cpu.r_ah.set$size($cast(ldiv % $cast$op1.get));</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="idiv">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        int ldiv = (((int)cpu.r_edx.get16()) &lt;&lt; 16 ) | ($maskcpu.r_eax.get16());
        int quot32 = ldiv / $op1.get;
        if (quot32 != (short)quot32)
            throw ProcessorException.DIVIDE_ERROR;
        cpu.r_eax.set$size($castquot32);
        cpu.r_edx.set$size($cast(int)(ldiv % $cast$op1.get));</snippet>
    <args size="16">Ew</args>
  </opcode>
  <opcode mnemonic="idiv">
    <return>Branch.None</return>
    <snippet>        if ($op1.get == 0)
            throw ProcessorException.DIVIDE_ERROR;
        long ldiv = (((0xffffffffL &amp; cpu.r_edx.get32())) &lt;&lt; 32 ) | (0xffffffffL &amp; cpu.r_eax.get32());
        long quot64 = ldiv / $op1.get;
        if (quot64 != (int)quot64)
            throw ProcessorException.DIVIDE_ERROR;
        cpu.r_eax.set32((int)quot64);
        cpu.r_edx.set32((int)(ldiv % $op1.get));</snippet>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            int iop1 = $cast$op1.get;
            int iop2 = $castcpu.r_eax.get$size();
            short res16 = (short) (iop1 * iop2);
            cpu.r_eax.set16(res16);
            cpu.setOSZAPC_Logic8(res16);
            if (res16 != (byte) res16)
            {
               cpu.of(true);
               cpu.cf(true);
            }</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            int iop1 = $cast$op1.get;
            int iop2 = $castcpu.r_eax.get$size();
            int res32 = (((int)(short) iop1)*((short)iop2));
            cpu.r_eax.set$size($castres32);
            cpu.r_edx.set$size($cast(res32 >> $size));
            cpu.setOSZAPC_Logic16(res32);
            if (res32 != (short) res32)
            {
               cpu.of(true);
               cpu.cf(true);
            }</snippet>
    <args size="16">Ew</args>
  </opcode>
  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            int iop1 = $cast$op1.get;
            int iop2 = $castcpu.r_eax.get$size();
            long res64 = (((long) iop1)*iop2);
            cpu.r_eax.set$size((int)res64);
            cpu.r_edx.set$size($cast(int)(res64 >> $size));
            cpu.setOSZAPC_Logic32((int)res64);
            if (res64 != (int) res64)
            {
               cpu.of(true);
               cpu.cf(true);
            }</snippet>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            int iop1 = $cast$op1.get;
            int iop2 = $cast$op2.get;
            int res32 = (((int)(short) iop1)*((short)iop2));
            $op1.set$castres32);
            cpu.setOSZAPC_Logic16(res32);
            if (res32 != (short) res32)
            {
               cpu.of(true);
               cpu.cf(true);
            }</snippet>
    <args size="16">Gw;Ew</args>
  </opcode>
  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            int iop1 = $cast$op1.get;
            int iop2 = $cast$op2.get;
            long res64 = (((long) iop1)*iop2);
            $op1.set(int)res64);
            cpu.setOSZAPC_Logic32((int)res64);
            if (res64 != (int) res64)
            {
               cpu.of(true);
               cpu.cf(true);
            }</snippet>
    <args size="32">Gd;Ed</args>
  </opcode>

  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            short iop1 = $cast$op3.get;
            short iop2 = $cast$op2.get;
            int res32 = (((int) iop1)*iop2);
            $op1.set$cast res32);
            cpu.setOSZAPC_Logic16(res32);
            if (res32 != (short) res32)
            {
               cpu.of(true);
               cpu.cf(true);
            }</snippet>
    <args size="16">Gw;Ew;Ib</args>
    <args size="16">Gw;Ew;Iw</args>
  </opcode>
  <opcode mnemonic="imul">
    <return>Branch.None</return>
    <snippet>            int iop1 = $cast$op3.get;
            int iop2 = $cast$op2.get;
            long res64 = (((long) iop1)*iop2);
            $op1.set(int)res64);
            cpu.setOSZAPC_Logic32((int)res64);
            if (res64 != (int) res64)
            {
               cpu.of(true);
               cpu.cf(true);
            }</snippet>
    <args size="32">Gd;Ed;Ib</args>
    <args size="32">Gd;Ed;Id</args>
  </opcode>

  <opcode mnemonic="f2xm1">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setST(0, Math.pow(2.0, cpu.fpu.ST(0))- 1.0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fabs">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setST(0, Math.abs(cpu.fpu.ST(0)));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fadd">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY))
            cpu.fpu.setInvalidOperation();
        cpu.fpu.setST(0, freg0+freg1);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fadd">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY))
            cpu.fpu.setInvalidOperation();
        $op1.setfreg0+freg1);</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="faddp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY))
            cpu.fpu.setInvalidOperation();
        $op1.setfreg0+freg1);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fbld">
    <return>Branch.None</return>
    <snippet>        byte[] data = $op1.getF;
        long n = 0;
        long decade = 1;
        for (int i = 0; i &lt; 9; i++) 
        {
            byte b = data[i];
            n += (b &amp; 0xf) * decade; 
            decade *= 10;
            n += ((b >> 4) &amp; 0xf) * decade; 
            decade *= 10;
        }
        byte sign = data[9];
        double m = (double)n;
        if (sign &lt; 0)
            m *= -1.0;
       cpu.fpu.push(m);</snippet>
    <args size="80">Mt</args>
  </opcode>

  <opcode mnemonic="fbstp">
    <return>Branch.None</return>
    <snippet>        byte[] data = new byte[10];
        long n = (long)Math.abs(cpu.fpu.ST(0));
        long decade = 1;
        for (int i = 0; i &lt; 9; i++) 
        {
            int val = (int) ((n % (decade * 10)) / decade);
            byte b = (byte) val;
            decade *= 10;
            val = (int) ((n % (decade * 10)) / decade);
            b |= (val &lt;&lt; 4);
            data[i] = b;
       }
       data[9] =  (cpu.fpu.ST(0) &lt; 0) ? (byte)0x80 : (byte)0x00;
       $op1.setF data);
       cpu.fpu.pop();</snippet>
    <args size="80">Mt</args>
  </opcode>

  <opcode mnemonic="fchs">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setST(0, -cpu.fpu.ST(0));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fclex">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.checkExceptions();
        cpu.fpu.clearExceptions();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fcom">
    <return>Branch.None</return>
    <snippet>                            int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if (Double.isNaN(freg0) || Double.isNaN(freg1))
            cpu.fpu.setInvalidOperation();
        else {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fcom">
    <return>Branch.None</return>
    <snippet>                            int newcode = 0xd;
        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (Double.isNaN(freg0) || Double.isNaN(freg1))
            cpu.fpu.setInvalidOperation();
        else {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;</snippet>
    <args size="64">ST0;STi</args>
  </opcode>
  <opcode mnemonic="fcomp">
    <return>Branch.None</return>
    <snippet>                            int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if (Double.isNaN(freg0) || Double.isNaN(freg1))
            cpu.fpu.setInvalidOperation();
        else {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fcomp">
    <return>Branch.None</return>
    <snippet>                            int newcode = 0xd;
        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (Double.isNaN(freg0) || Double.isNaN(freg1))
            cpu.fpu.setInvalidOperation();
        else {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();</snippet>
    <args size="64">ST0;STi</args>
  </opcode>
  <opcode mnemonic="fcompp">
    <return>Branch.None</return>
    <snippet>                            int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        if (Double.isNaN(freg0) || Double.isNaN(freg1))
            cpu.fpu.setInvalidOperation();
        else {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();
        cpu.fpu.pop();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="ftst">
    <return>Branch.None</return>
    <snippet>                            int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = 0.0;
        if (Double.isNaN(freg0))
            cpu.fpu.setInvalidOperation();
        else {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fcos">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        if (Double.isInfinite(freg0))
	    cpu.fpu.setInvalidOperation();
        if ((freg0 > Long.MAX_VALUE) || (freg0 &lt; Long.MIN_VALUE))
	    cpu.fpu.conditionCode |= 4; // set C2
        else
            cpu.fpu.setST(0, Math.cos(freg0));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fdiv">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg1 == 0.0) &amp;&amp; !Double.isNaN(freg0) &amp;&amp; !Double.isInfinite(freg0))
            cpu.fpu.setZeroDivide();
        cpu.fpu.setST(0, freg0/freg1);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fdiv">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg0 == 0.0) &amp;&amp; !Double.isNaN(freg1) &amp;&amp; !Double.isInfinite(freg1))
            cpu.fpu.setZeroDivide();
        $op1.set freg0/freg1);</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fdivp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg1 == 0.0) &amp;&amp; !Double.isNaN(freg0) &amp;&amp; !Double.isInfinite(freg0))
            cpu.fpu.setZeroDivide();
        $op1.setfreg0/freg1);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fdivr">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg0 == 0.0) &amp;&amp; !Double.isNaN(freg1) &amp;&amp; !Double.isInfinite(freg1))
            cpu.fpu.setZeroDivide();
        cpu.fpu.setST(0, freg1/freg0);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fdivr">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg0 == 0.0) &amp;&amp; !Double.isNaN(freg1) &amp;&amp; !Double.isInfinite(freg1))
            cpu.fpu.setZeroDivide();
        $op1.set freg1/freg0);</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fdivrp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg0 == 0.0) &amp;&amp; !Double.isNaN(freg1) &amp;&amp; !Double.isInfinite(freg1))
            cpu.fpu.setZeroDivide();
        $op1.setfreg1/freg0);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="ffree">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setTagEmpty(0);</snippet>
    <args size="64">ST0</args>
  </opcode>
  <opcode mnemonic="ffree">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setTagEmpty(1);</snippet>
    <args size="64">ST1</args>
  </opcode>

  <opcode mnemonic="fidiv">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = (double)$op1.get;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg0 == 0.0) &amp;&amp; !Double.isNaN(freg1) &amp;&amp; !Double.isInfinite(freg1))
            cpu.fpu.setZeroDivide();
        cpu.fpu.setST(0, freg0/freg1);</snippet>
    <args size="16">Mw</args>
    <args size="32">Md</args>
  </opcode>

  <opcode mnemonic="fidivr">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = (double)$op1.get;
        if (((freg0 == 0.0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg0) &amp;&amp; Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
	if ((freg0 == 0.0) &amp;&amp; !Double.isNaN(freg1) &amp;&amp; !Double.isInfinite(freg1))
            cpu.fpu.setZeroDivide();
        cpu.fpu.setST(0, freg1/freg0);</snippet>
    <args size="16">Mw</args>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fiadd">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setST(0, cpu.fpu.ST(0)+$op1.get);</snippet>
    <args size="16">Mw</args>
    <args size="32">Md</args>
  </opcode>

  <opcode mnemonic="fild">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push((double)$op1.get);</snippet>
    <args size="16">Mw</args>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fimul">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = (double)$op1.get;
        if ((Double.isInfinite(freg0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg1) &amp;&amp; (freg0 == 0.0))) 
            cpu.fpu.setInvalidOperation();
        cpu.fpu.setST(0, freg0*freg1);</snippet>
    <args size="16">Mw</args>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  
  <opcode mnemonic="fincstp">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.top += 1; cpu.fpu.top &amp;= 7;</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fisub">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setST(0, cpu.fpu.ST(0)-$op1.get);</snippet>
    <args size="16">Mw</args>
    <args size="32">Md</args>
  </opcode>

  <opcode mnemonic="fisubr">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setST(0, $op1.get-cpu.fpu.ST(0));</snippet>
    <args size="16">Mw</args>
    <args size="32">Md</args>
  </opcode>

  <opcode mnemonic="fist">
    <return>Branch.None</return>
    <snippet>        double cast = cpu.fpu.round(cpu.fpu.ST(0));
        if (Math.abs(cast) > Short.MAX_VALUE)
            cast = (double)Short.MIN_VALUE;
        $op1.set(short)cast);</snippet>
    <args size="16">Mw</args>
  </opcode>
  <opcode mnemonic="fist">
    <return>Branch.None</return>
    <snippet>        $op1.set(int)cpu.fpu.round(cpu.fpu.ST(0)));</snippet>
    <args size="32">Md</args>
  </opcode>
  <opcode mnemonic="fist">
    <return>Branch.None</return>
    <snippet>        $op1.set(long)cpu.fpu.round(cpu.fpu.ST(0)));</snippet>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fisttp">
    <return>Branch.None</return>
    <snippet>        double cast = cpu.fpu.ST(0);
        if (Math.abs(cast) > Short.MAX_VALUE)
            cast = (double)Short.MIN_VALUE;
        $op1.set(short)(Math.signum(cast)*Math.floor(Math.abs(cast))));
        cpu.fpu.pop();</snippet>
    <args size="16">Mw</args>
  </opcode>

  <opcode mnemonic="fistp">
    <return>Branch.None</return>
    <snippet>        double cast = cpu.fpu.round(cpu.fpu.ST(0));
        if (Math.abs(cast) > Short.MAX_VALUE)
            cast = (double)Short.MIN_VALUE;
        $op1.set(short)cast);
        cpu.fpu.pop();</snippet>
    <args size="16">Mw</args>
  </opcode>
  <opcode mnemonic="fistp">
    <return>Branch.None</return>
    <snippet>        $op1.set(int)cpu.fpu.round(cpu.fpu.ST(0)));
        cpu.fpu.pop();</snippet>
    <args size="32">Md</args>
  </opcode>
  <opcode mnemonic="fistp">
    <return>Branch.None</return>
    <snippet>        $op1.set(long)cpu.fpu.round(cpu.fpu.ST(0)));
        cpu.fpu.pop();</snippet>
    <args size="64">Mq</args>
  </opcode>
  
  <opcode mnemonic="fld">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push($op1.getF);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fld">
    <return>Branch.None</return>
    <snippet>        byte[] raw = $op1.getF;
        long val = 0L;
        for (int i=0; i &lt; 8; i++)
            val |= ((0xff &amp; raw[i]) &lt;&lt; (8*i));
        cpu.fpu.push(Double.longBitsToDouble(val));</snippet>
    <args size="80">Mt</args>
  </opcode>

  <opcode mnemonic="fld">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push($op2.get);</snippet>
    <args size="64">ST0;STi</args>
  </opcode>

  <opcode mnemonic="fld1">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(1.0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fldcw">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setControl($op1.get);</snippet>
    <args size="16">Mw</args>
  </opcode>

  <opcode mnemonic="fldl2e">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(1.0/Math.log(2));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fldl2t">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(Math.log(10.0)/Math.log(2));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fldlg2">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(Math.log(2.0)/Math.log(10.0));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fldln2">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(Math.log(2));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fldpi">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(Math.PI);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fldz">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.push(0.0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fmul">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if ((Double.isInfinite(freg0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg1) &amp;&amp; (freg0 == 0.0))) 
            cpu.fpu.setInvalidOperation();
        cpu.fpu.setST(0, freg0*freg1);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fmul">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((Double.isInfinite(freg0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg1) &amp;&amp; (freg0 == 0.0))) 
            cpu.fpu.setInvalidOperation();
        $op1.set freg0*freg1);</snippet>
    <args size="64">STi;STi</args>
  </opcode>
  <opcode mnemonic="fmulp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((Double.isInfinite(freg0) &amp;&amp; (freg1 == 0.0)) || (Double.isInfinite(freg1) &amp;&amp; (freg0 == 0.0))) 
            cpu.fpu.setInvalidOperation();
        $op1.setfreg0*freg1);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fninit">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.init();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fnstcw">
    <return>Branch.None</return>
    <snippet>        $op1.set$castcpu.fpu.getControl());</snippet>
    <args size="16">AX</args>
    <args size="16">Mw</args>
  </opcode>

  <opcode mnemonic="fnstsw">
    <return>Branch.None</return>
    <snippet>        $op1.set$castcpu.fpu.getStatus());</snippet>
    <args size="16">AX</args>
    <args size="16">Mw</args>
  </opcode>

  <opcode mnemonic="fprem">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        int d = Math.getExponent(freg0) - Math.getExponent(freg1);
        if (d &lt; 64)
        {
            // full remainder
            cpu.fpu.conditionCode &amp;= ~4; // clear C2
            freg0 = freg0 % freg1;
            // compute least significant bits -> C0 C3 C1
            long i = (long)Math.rint(freg0 / freg1);
            cpu.fpu.conditionCode &amp;= 4;
            if ((i &amp; 1) != 0) cpu.fpu.conditionCode |= 2;
            if ((i &amp; 2) != 0) cpu.fpu.conditionCode |= 8;
            if ((i &amp; 4) != 0) cpu.fpu.conditionCode |= 1;
        }
        else
        {
            // partial remainder
            cpu.fpu.conditionCode |= 4; // set C2
            int n = 63; // implementation dependent in manual
            double f = Math.pow(2.0, (double)(d - n));
            double z = (freg0 / freg1) / f;
            double qq = (z &lt; 0) ? Math.ceil(z) : Math.floor(z);
            freg0 = freg0 - (freg1 * qq * f);
        }
        cpu.fpu.setST(0, freg0);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fprem1">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        int d = Math.getExponent(freg0) - Math.getExponent(freg1);
        if (d &lt; 64)
        {
            // full remainder
            cpu.fpu.conditionCode &amp;= ~4; // clear C2
            double z = Math.IEEEremainder(freg0, freg1);
            // compute least significant bits -> C0 C3 C1
            long i = (long)Math.rint(freg0 / freg1);
            cpu.fpu.conditionCode &amp;= 4;
            if ((i &amp; 1) != 0) cpu.fpu.conditionCode |= 2;
            if ((i &amp; 2) != 0) cpu.fpu.conditionCode |= 8;
            if ((i &amp; 4) != 0) cpu.fpu.conditionCode |= 1;
            cpu.fpu.setST(0, z);
        }
        else
        {
            // partial remainder
            cpu.fpu.conditionCode |= 4; // set C2
            int n = 63; // implementation dependent in manual
            double f = Math.pow(2.0, (double)(d - n));
            double z = (freg0 / freg1) / f;
            double qq = (z &lt; 0) ? Math.ceil(z) : Math.floor(z);
            cpu.fpu.setST(0, freg0 - (freg1 * qq * f));
        }</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fpatan">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        double res = Math.atan(freg1/freg0);
        boolean st0P = freg0 > 0;
        boolean st1P = freg1 > 0;
        if (!st0P)
        {
            if (st1P)
                res += Math.PI;
            else
                res -= Math.PI;
        }
        cpu.fpu.setST(1, res);
        cpu.fpu.pop();
        cpu.fpu.setC1(false);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fptan">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        if ((freg0 > Math.pow(2.0, 63.0)) || (freg0 &lt; -1.0*Math.pow(2.0, 63.0))) {
            if (Double.isInfinite(freg0))
                cpu.fpu.setInvalidOperation();
            cpu.fpu.conditionCode |= 4;
        } else 
        {
            cpu.fpu.conditionCode &amp;= ~4;
            cpu.fpu.setST(0, Math.tan(freg0));
            cpu.fpu.push(1.0);
        }</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="frndint">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        if (!Double.isInfinite(freg0)) // preserve infinities
        {
            switch(cpu.fpu.getRoundingControl())
            {
                case FpuState.FPU_ROUNDING_CONTROL_EVEN:
                    cpu.fpu.setST(0, Math.rint(freg0));
                    break;
                case FpuState.FPU_ROUNDING_CONTROL_DOWN:
                    cpu.fpu.setST(0, Math.floor(freg0));
                    break;
                case FpuState.FPU_ROUNDING_CONTROL_UP:
                    cpu.fpu.setST(0, Math.ceil(freg0));
                    break;
                case FpuState.FPU_ROUNDING_CONTROL_TRUNCATE:
                    cpu.fpu.setST(0, Math.signum(freg0) * Math.floor(Math.abs(freg0)));
                    break;
                default:
                    throw new IllegalStateException("Invalid rounding control value");
            }
        }
</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fscale">
    <return>Branch.None</return>
    <snippet>        cpu.fpu.setST(0, Math.scalb(cpu.fpu.ST(0), (int)cpu.fpu.ST(1)));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fndisi">
    <return>Branch.None</return>
    <snippet></snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fsetpm">
    <return>Branch.None</return>
    <snippet></snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fsin">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        if (Double.isInfinite(freg0))
	    cpu.fpu.setInvalidOperation();
        if ((freg0 > Long.MAX_VALUE) || (freg0 &lt; Long.MIN_VALUE))
	    cpu.fpu.conditionCode |= 4; // set C2
        else
            cpu.fpu.setST(0, Math.sin(freg0));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fst">
    <return>Branch.None</return>
    <snippet>        $op1.setF(float)cpu.fpu.ST(0));</snippet>
    <args size="32">Md</args>
  </opcode>
  <opcode mnemonic="fst">
    <return>Branch.None</return>
    <snippet>        $op1.setFcpu.fpu.ST(0));</snippet>
    <args size="64">Mq</args>
  </opcode>

  <opcode mnemonic="fst">
    <return>Branch.None</return>
    <snippet>        $op1.setcpu.fpu.ST(0));</snippet>
    <args size="64">STi</args>
  </opcode>

  <opcode mnemonic="fstp">
    <return>Branch.None</return>
    <snippet>        $op1.setF(float)cpu.fpu.ST(0));
        cpu.fpu.pop();</snippet>
    <args size="32">Md</args>
  </opcode>
  <opcode mnemonic="fstp">
    <return>Branch.None</return>
    <snippet>        $op1.setFcpu.fpu.ST(0));
        cpu.fpu.pop();</snippet>
    <args size="64">Mq</args>
    <args size="80">Mt</args>
  </opcode>
  <opcode mnemonic="fstp">
    <return>Branch.None</return>
    <snippet>        $op1.setcpu.fpu.ST(0));
        cpu.fpu.pop();</snippet>
    <args size="64">STi</args>
  </opcode>

  <opcode mnemonic="fldenv_o16">
    <return>Branch.None</return>
    <snippet>        System.out.println("Warning: Using incomplete opcode: FLDENV_14");
        // check for floating point exceptions
        int addr = $op1.get;
        cpu.fpu.setControl(cpu.linearMemory.getWord(addr));
        cpu.fpu.setStatus(cpu.linearMemory.getWord(addr+2));
        cpu.fpu.setTagWord(cpu.linearMemory.getWord(addr+4));
        //cpu.linearMemory.setWord(addr + 6, (short) 0 /* cpu.fpu.getIP()  offset*/);
        //cpu.linearMemory.setWord(addr + 8, (short) 0 /* (selector &amp; 0xFFFF)*/);
        //cpu.linearMemory.setWord(addr + 10, (short) 0 /* operand pntr offset*/);
        //cpu.linearMemory.setWord(addr + 12, (short) 0 /* operand pntr selector &amp; 0xFFFF*/);</snippet>
    <args size="16">M</args>
  </opcode>
  <opcode mnemonic="fldenv_o32">
    <return>Branch.None</return>
    <snippet>        System.out.println("Warning: Using incomplete opcode: FLDENV_28");
        // check for floating point exceptions
        int addr = $op1.get;
        cpu.fpu.setControl(cpu.linearMemory.getDoubleWord(addr));
        cpu.fpu.setStatus(cpu.linearMemory.getDoubleWord(addr+4));
        cpu.fpu.setTagWord(cpu.linearMemory.getDoubleWord(addr+8));
        //cpu.linearMemory.setWord(addr + 6, (short) 0 /* cpu.fpu.getIP()  offset*/);
        //cpu.linearMemory.setWord(addr + 8, (short) 0 /* (selector &amp; 0xFFFF)*/);
        //cpu.linearMemory.setWord(addr + 10, (short) 0 /* operand pntr offset*/);
        //cpu.linearMemory.setWord(addr + 12, (short) 0 /* operand pntr selector &amp; 0xFFFF*/);</snippet>
    <args size="16">M</args>
  </opcode>

  <opcode mnemonic="fstenv_o16">
    <return>Branch.None</return>
    <snippet>        System.out.println("Warning: Using incomplete opcode: FSTENV_14");
        // check for floating point exceptions
        int addr = $op1.get;
        cpu.linearMemory.setWord(addr, (short) cpu.fpu.getControl());
        cpu.linearMemory.setWord(addr + 2, (short) cpu.fpu.getStatus());
        cpu.linearMemory.setWord(addr + 4, (short) cpu.fpu.getTagWord());
        cpu.linearMemory.setWord(addr + 6, (short) 0 /* cpu.fpu.getIP()  offset*/);
        cpu.linearMemory.setWord(addr + 8, (short) 0 /* (selector &amp; 0xFFFF)*/);
        cpu.linearMemory.setWord(addr + 10, (short) 0 /* operand pntr offset*/);
        cpu.linearMemory.setWord(addr + 12, (short) 0 /* operand pntr selector &amp; 0xFFFF*/);</snippet>
    <args size="16">M</args>
  </opcode>
  <opcode mnemonic="fnstenv_o16">
    <return>Branch.None</return>
    <snippet>        System.out.println("Warning: Using incomplete opcode: FNSTENV_14");
        int addr = $op1.get;
        cpu.linearMemory.setWord(addr, (short) cpu.fpu.getControl());
        cpu.linearMemory.setWord(addr + 2, (short) cpu.fpu.getStatus());
        cpu.linearMemory.setWord(addr + 4, (short) cpu.fpu.getTagWord());
        cpu.linearMemory.setWord(addr + 6, (short) 0 /* cpu.fpu.getIP()  offset*/);
        cpu.linearMemory.setWord(addr + 8, (short) 0 /* (selector &amp; 0xFFFF)*/);
        cpu.linearMemory.setWord(addr + 10, (short) 0 /* operand pntr offset*/);
        cpu.linearMemory.setWord(addr + 12, (short) 0 /* operand pntr selector &amp; 0xFFFF*/);</snippet>
    <args size="16">M</args>
  </opcode>
  <opcode mnemonic="fnstenv_o32">
    <return>Branch.None</return>
    <snippet>        System.out.println("Warning: Using incomplete opcode: FNSTENV_28");
        int addr = $op1.get;
        cpu.linearMemory.setDoubleWord(addr, 0xffff &amp; cpu.fpu.getControl());
        cpu.linearMemory.setDoubleWord(addr + 4, 0xffff &amp; cpu.fpu.getStatus());
        cpu.linearMemory.setDoubleWord(addr + 8, 0xffff &amp; cpu.fpu.getTagWord());
        cpu.linearMemory.setDoubleWord(addr + 12, (short) 0 /* cpu.fpu.getIP()  offset*/);
        cpu.linearMemory.setDoubleWord(addr + 16, (short) 0 /* (selector &amp; 0xFFFF)*/);
        cpu.linearMemory.setDoubleWord(addr + 20, (short) 0 /* operand pntr offset*/);
        cpu.linearMemory.setDoubleWord(addr + 24, (short) 0 /* operand pntr selector &amp; 0xFFFF*/);</snippet>
    <args size="32">M</args>
  </opcode>

  <opcode mnemonic="fnsave_o16">
    <return>Branch.None</return>
    <snippet>        System.out.println("Warning: Using incomplete opcode: FNSAVE_94");
        int addr = $op1.get;
        cpu.linearMemory.setWord(addr, (short) cpu.fpu.getControl());
        cpu.linearMemory.setWord(addr + 2, (short) cpu.fpu.getStatus());
        cpu.linearMemory.setWord(addr + 4, (short) cpu.fpu.getTagWord());
        cpu.linearMemory.setWord(addr + 6, (short) 0 /* cpu.fpu.getIP()  offset*/);
        cpu.linearMemory.setWord(addr + 8, (short) 0 /* (selector &amp; 0xFFFF)*/);
        cpu.linearMemory.setWord(addr + 10, (short) 0 /* operand pntr offset*/);
        cpu.linearMemory.setWord(addr + 12, (short) 0 /* operand pntr selector &amp; 0xFFFF*/);</snippet>
        for (int i = 0; i &lt; 8; i++) {
            byte[] extended = FpuState64.doubleToExtended(fpu.ST(i), false /* this is WRONG!!!!!!! */);
            for (int j = 0; j &lt; 10; j++)
                cpu.linearMemory.setByte(addr + 14 + j + (10 * i), extended[j]);
        }
        cpu.fpu.init();
    <args size="16">M</args>
  </opcode>
  <opcode mnemonic="fnsave_o32">
    <return>Branch.None</return>
    <snippet>        System.out.println("Warning: Using incomplete opcode: FNSAVE_108");
        int addr = $op1.get;
        cpu.linearMemory.setDoubleWord(addr, cpu.fpu.getControl());
        cpu.linearMemory.setDoubleWord(addr + 4, cpu.fpu.getStatus());
        cpu.linearMemory.setDoubleWord(addr + 8, cpu.fpu.getTagWord());
        cpu.linearMemory.setDoubleWord(addr + 12, 0 /* cpu.fpu.getIP()  offset*/);
        cpu.linearMemory.setDoubleWord(addr + 16, 0 /* (selector &amp; 0xFFFF)*/);
        cpu.linearMemory.setDoubleWord(addr + 20, 0 /* operand pntr offset*/);
        cpu.linearMemory.setDoubleWord(addr + 24, 0 /* operand pntr selector &amp; 0xFFFF*/);</snippet>
        for (int i = 0; i &lt; 8; i++) {
            byte[] extended = FpuState64.doubleToExtended(fpu.ST(i), false /* this is WRONG!!!!!!! */);
            for (int j = 0; j &lt; 10; j++)
                cpu.linearMemory.setByte(addr + 28 + j + (10 * i), extended[j]);
        }
        cpu.fpu.init();
    <args size="16">M</args>
  </opcode>

  <opcode mnemonic="frstor_o16">
    <return>Branch.None</return>
    <snippet>        System.out.println("Warning: Using incomplete opcode: FRSTOR_94");
        int addr = $op1.get;
        cpu.fpu.setControl(cpu.linearMemory.getWord(addr));
        cpu.fpu.setStatus(cpu.linearMemory.getWord(addr+2));
        cpu.fpu.setTagWord(cpu.linearMemory.getWord(addr+4));
        //cpu.linearMemory.setWord(addr + 6, (short) 0 /* cpu.fpu.getIP()  offset*/);
        //cpu.linearMemory.setWord(addr + 8, (short) 0 /* (selector &amp; 0xFFFF)*/);
        //cpu.linearMemory.setWord(addr + 10, (short) 0 /* operand pntr offset*/);
        //cpu.linearMemory.setWord(addr + 12, (short) 0 /* operand pntr selector &amp; 0xFFFF*/);
        //for (int i = 0; i &lt; 8; i++) {
        //    byte[] extended = FpuState64.doubleToExtended(fpu.ST(i), false /* this is WRONG!!!!!!! */);
        //    for (int j = 0; j &lt; 10; j++)
        //       seg0.setByte(addr0 + 14 + j + (10 * i), extended[j]);
        //}</snippet>
    <args size="16">M</args>
  </opcode>
  <opcode mnemonic="frstor_o32">
    <return>Branch.None</return>
    <snippet>        System.out.println("Warning: Using incomplete opcode: FRSTOR_108");
        int addr = $op1.get;
        cpu.fpu.setControl(cpu.linearMemory.getDoubleWord(addr));
        cpu.fpu.setStatus(cpu.linearMemory.getDoubleWord(addr+4));
        cpu.fpu.setTagWord(cpu.linearMemory.getDoubleWord(addr+8));
        //cpu.linearMemory.setWord(addr + 6, (short) 0 /* cpu.fpu.getIP()  offset*/);
        //cpu.linearMemory.setWord(addr + 8, (short) 0 /* (selector &amp; 0xFFFF)*/);
        //cpu.linearMemory.setWord(addr + 10, (short) 0 /* operand pntr offset*/);
        //cpu.linearMemory.setWord(addr + 12, (short) 0 /* operand pntr selector &amp; 0xFFFF*/);
        //for (int i = 0; i &lt; 8; i++) {
        //    byte[] extended = FpuState64.doubleToExtended(fpu.ST(i), false /* this is WRONG!!!!!!! */);
        //    for (int j = 0; j &lt; 10; j++)
        //       seg0.setByte(addr0 + 14 + j + (10 * i), extended[j]);
        //}</snippet>
    <args size="16">M</args>
  </opcode>

  <opcode mnemonic="fsqrt">
    <return>Branch.None</return>
    <snippet>        if (cpu.fpu.ST(0) &lt; 0)
			cpu.fpu.setInvalidOperation();
        cpu.fpu.setST(0, Math.sqrt(cpu.fpu.ST(0)));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fsub">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY)) 
		    cpu.fpu.setInvalidOperation();
        cpu.fpu.setST(0, freg0-freg1);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fsub">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY)) 
		    cpu.fpu.setInvalidOperation();
        $op1.set freg0-freg1);</snippet>
    <args size="64">STi;STi</args>
  </opcode>
  <opcode mnemonic="fsubp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY)) 
		    cpu.fpu.setInvalidOperation();
        $op1.set freg0-freg1);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fsubr">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.getF;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY)) 
		    cpu.fpu.setInvalidOperation();
        cpu.fpu.setST(0, freg1-freg0);</snippet>
    <args size="32">Md</args>
    <args size="64">Mq</args>
  </opcode>
  <opcode mnemonic="fsubr">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY)) 
		    cpu.fpu.setInvalidOperation();
        $op1.set freg1-freg0);</snippet>
    <args size="64">STi;STi</args>
  </opcode>
  <opcode mnemonic="fsubrp">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if ((freg0 == Double.NEGATIVE_INFINITY &amp;&amp; freg1 == Double.NEGATIVE_INFINITY) || (freg0 == Double.POSITIVE_INFINITY &amp;&amp; freg1 == Double.POSITIVE_INFINITY)) 
		    cpu.fpu.setInvalidOperation();
        $op1.set freg1-freg0);
        cpu.fpu.pop();</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fucom">
    <return>Branch.None</return>
    <snippet>        int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.get;
        if (!(Double.isNaN(freg0) || Double.isNaN(freg1)))
        {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;</snippet>
    <args size="64">STi</args>
  </opcode>

  <opcode mnemonic="fucomp">
    <return>Branch.None</return>
    <snippet>        int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.get;
        if (!(Double.isNaN(freg0) || Double.isNaN(freg1)))
        {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();</snippet>
    <args size="64">STi</args>
  </opcode>

  <opcode mnemonic="fucomip">
    <return>Branch.None</return>
    <snippet>        double freg0 = $op1.get;
        double freg1 = $op2.get;
        if (freg0 > freg1)
        {
            cpu.zf = cpu.pf = cpu.cf = false;
            cpu.flagStatus &amp;= ~(ZF | PF | CF);
        } else if (freg0 &lt; freg1)
        {
            cpu.zf = cpu.pf = false;
            cpu.cf = true;
            cpu.flagStatus &amp;= ~(ZF | PF | CF);
        } else if (freg0 == freg1)
        {
            cpu.cf = cpu.pf = false;
            cpu.zf = true;
            cpu.sf = false;
            cpu.flagStatus &amp;= ~(ZF | PF | CF | SF);
        } else
        {
            cpu.zf = cpu.pf = cpu.cf = true;
            cpu.flagStatus &amp;= ~(ZF | PF | CF);
        }
        cpu.af = false;
        cpu.sf = false;
        cpu.flagStatus &amp;= ~(AF | SF);
        cpu.fpu.pop();</snippet>
    <args size="64">ST0;STi</args>
  </opcode>

  <opcode mnemonic="fucompp">
    <return>Branch.None</return>
    <snippet>        int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = $op1.get;
        if (!(Double.isNaN(freg0) || Double.isNaN(freg1)))
        {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();
        cpu.fpu.pop();</snippet>
    <args size="64">STi</args>
  </opcode>

  <opcode mnemonic="fucompp">
    <return>Branch.None</return>
    <snippet>        int newcode = 0xd;
        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        if (!(Double.isNaN(freg0) || Double.isNaN(freg1)))
        {
            if (freg0 > freg1) newcode = 0;
            else if (freg0 &lt; freg1) newcode = 1;
            else newcode = 8;
        }
        cpu.fpu.conditionCode &amp;= 2;
        cpu.fpu.conditionCode |= newcode;
        cpu.fpu.pop();
        cpu.fpu.pop();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fxam">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        cpu.fpu.setC1(freg0 &lt; 0.0);
        if (Double.isInfinite(freg0))
        {
            cpu.fpu.setC0(true);
            cpu.fpu.setC2(true);
            cpu.fpu.setC3(false);
        } else if(Double.isNaN(freg0))
        {
            cpu.fpu.setC0(true);
            cpu.fpu.setC2(false);
            cpu.fpu.setC3(false);
        } else if(freg0 == 0.0)
        {
            cpu.fpu.setC0(false);
            cpu.fpu.setC2(false);
            cpu.fpu.setC3(true);
        } else
        {
            cpu.fpu.setC0(false);
            cpu.fpu.setC2(true);
            cpu.fpu.setC3(false);
        } //ignore unsupported, empty and denormal</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fxch">
    <return>Branch.None</return>
    <snippet>        double tmp = $op1.get;
        $op1.set$op2.get);
        $op2.settmp);</snippet>
    <args size="64">STi;STi</args>
  </opcode>

  <opcode mnemonic="fyl2x">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        if (freg0 &lt; 0)
        {
            cpu.fpu.setInvalidOperation();
        }
        else if (Double.isInfinite(freg0))
        {
            if (freg1 == 0)
                cpu.fpu.setInvalidOperation();
            else if (freg1 > 0)
                cpu.fpu.setST(1, freg0);
            else
                cpu.fpu.setST(1, -freg0);
        }
        else if ((freg0 == 1) &amp;&amp; (Double.isInfinite(freg1)))
            cpu.fpu.setInvalidOperation();
        else if (freg0 == 0)
        {
            if (freg1 == 0)
                cpu.fpu.setInvalidOperation();
            else if (!Double.isInfinite(freg1))
                cpu.fpu.setZeroDivide();
            else
                cpu.fpu.setST(1, -freg1);
        }
        else if (Double.isInfinite(freg1))
        {
            if (freg0 &lt; 1)
                cpu.fpu.setST(1, -freg1);
        }
        else
        {
            cpu.fpu.setST(1, freg1 * Math.log(freg0)/Math.log(2.0));
        }
        cpu.fpu.pop();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="fyl2xp1">
    <return>Branch.None</return>
    <snippet>        double freg0 = cpu.fpu.ST(0);
        double freg1 = cpu.fpu.ST(1);
        if (freg0 == 0)
        {
            if (Double.isInfinite(freg1))
                cpu.fpu.setInvalidOperation();
            else cpu.fpu.setST(1, 0.0);
        }
        else if (Double.isInfinite(freg1))
        {
            if (freg0 &lt; 0)
                cpu.fpu.setST(1, -freg1);
        }
        else
        {
            cpu.fpu.setST(1, freg1 * Math.log(freg0 + 1.0)/Math.log(2.0));
        }
        cpu.fpu.pop();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="wait">
    <return>Branch.None</return>
    <snippet>            cpu.fpu.checkExceptions();</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lds_o16" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get162);
        int offset = $op2.get160);
        cpu.ds(selector);
        $op1.set$castoffset);</snippet>
    <args size="16">Gw;M</args>
  </opcode>

  <opcode mnemonic="lds_o32" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get164);
        int offset = $op2.get320);
        cpu.ds(selector);
        $op1.set$castoffset);</snippet>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="les_o16" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get162);
        int offset = $op2.get160);
        cpu.es(selector);
        $op1.set$castoffset);</snippet>
    <args size="16">Gw;M</args>
  </opcode>

  <opcode mnemonic="les_o32" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get164);
        int offset = $op2.get320);
        cpu.es(selector);
        $op1.set$castoffset);</snippet>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="lfs_o16" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get162);
        int offset = $op2.get160);
        cpu.fs(selector);
        $op1.set$castoffset);</snippet>
    <args size="16">Gw;M</args>
  </opcode>

  <opcode mnemonic="lfs_o32" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get164);
        int offset = $op2.get320);
        cpu.fs(selector);
        $op1.set$castoffset);</snippet>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="lgs_o16" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get162);
        int offset = $op2.get160);
        cpu.gs(selector);
        $op1.set$castoffset);</snippet>
    <args size="16">Gw;M</args>
  </opcode>

  <opcode mnemonic="lgs_o32" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get164);
        int offset = $op2.get320);
        cpu.gs(selector);
        $op1.set$castoffset);</snippet>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="lss_o16" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get162);
        int offset = $op2.get160);
        cpu.ss(selector);
        $op1.set$castoffset);</snippet>
    <args size="16">Gw;M</args>
  </opcode>

  <opcode mnemonic="lss_o32" mem="true">
      <return>Branch.None</return>
      <snippet>        int selector = 0xFFFF &amp; $op2.get164);
        int offset = $op2.get320);
        cpu.ss(selector);
        $op1.set$castoffset);</snippet>
    <args size="32">Gd;M</args>
  </opcode>

  <opcode mnemonic="mul">
    <return>Branch.None</return>
    <snippet>            cpu.af = false;
        int res16 = ($op1.get &amp; 0xff) * (0xFF &amp; cpu.r_eax.get8());
        cpu.r_eax.set16(res16);
        cpu.setOSZAPC_Logic8(res16);
        cpu.cf = cpu.of = (cpu.r_eax.getHigh() != 0);</snippet>
    <args size="8">Eb</args>
  </opcode>
  <opcode mnemonic="mul">
    <return>Branch.None</return>
    <snippet>            cpu.af = false;
            long res64 = ($mask$op1.get) * ($mask cpu.r_eax.get$size());
            cpu.r_eax.set$size($castres64);
            cpu.r_edx.set$size($cast(res64 >> $size));
            cpu.setOSZAPC_Logic16((int)res64);
            cpu.cf = cpu.of = (cpu.r_edx.get$size() != 0);</snippet>
    <args size="16">Ew</args>
  </opcode>
  <opcode mnemonic="mul">
    <return>Branch.None</return>
    <snippet>            cpu.af = false;
            long res64 = (0xffffffffL &amp; $op1.get) * (0xffffffffL &amp; cpu.r_eax.get$size());
            cpu.r_eax.set$size($castres64);
            cpu.r_edx.set$size($cast(res64 >> $size));
            cpu.setOSZAPC_Logic32((int)res64);
            cpu.cf = cpu.of = (cpu.r_edx.get$size() != 0);</snippet>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="neg">
    <return>Branch.None</return>
    <snippet>            cpu.flagOp1 = $op1.get;
            cpu.flagResult = $cast(-cpu.flagOp1);
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.NEG$size;
            cpu.flagStatus = OSZAPC;</snippet>
    <args size="8">Eb</args>
    <args size="16">Ew</args>
    <args size="32">Ed</args>
  </opcode>

  <opcode mnemonic="cmpsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.cmpsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cmpsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.cmpsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cmpsw_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.cmpsw_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cmpsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.cmpsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cmpsd_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.cmpsd_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="cmpsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.cmpsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_cmpsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_cmpsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_cmpsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_cmpsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_cmpsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_cmpsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_cmpsw_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_cmpsw_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_cmpsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_cmpsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_cmpsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_cmpsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_cmpsd_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_cmpsd_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_cmpsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_cmpsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_cmpsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_cmpsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsw_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsw_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsd_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsd_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="lodsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.lodsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_lodsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_lodsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_lodsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_lodsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_lodsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_lodsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_lodsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_lodsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsw_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsw_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsd_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsd_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="movsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.movsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_movsb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsb_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_movsb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsb_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsw_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsw_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsw_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsw_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_movsw_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsw_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsd_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsd_a16(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_movsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_movsd_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_movsd_a32(cpu, seg);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="scasb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.scasb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="scasb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.scasb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="scasw_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.scasw_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="scasw_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.scasw_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="scasd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.scasd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_scasb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repe_scasb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_scasb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_scasb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_scasb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_scasb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_scasb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_scasb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_scasw_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repe_scasw_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_scasw_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repe_scasw_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_scasw_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_scasw_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_scasw_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_scasw_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_scasd_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_scasd_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_scasd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_scasd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_scasd_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_scasd_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_scasd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.repne_scasd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosw_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosw_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosw_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosw_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosd_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosd_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="stosd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.stosd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_stosb_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosb_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_stosb_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosb_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosw_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosw_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosw_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosw_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_stosw_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosw_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="repne_stosw_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosw_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosd_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosd_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>
  <opcode mnemonic="repne_stosd_a16">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosd_a16(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rep_stosd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>
  <opcode mnemonic="repne_stosd_a32">
    <return>Branch.None</return>
    <snippet>        StaticOpcodes.rep_stosd_a32(cpu);</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="rcl">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; 0x1f;
            shift %= $size+1;
            long val = $mask$op1.get;
            val |= cpu.cf() ? 1L &lt;&lt; $size : 0;
            val = (val &lt;&lt; shift) | (val &gt;&gt;&gt; ($size+1-shift));
            $op1.set$cast(int)val);
            boolean bit31 = (val &amp; (1L &lt;&lt; ($size-1))) != 0;
            boolean bit32 = (val &amp; (1L &lt;&lt; ($size))) != 0;
            cpu.cf(bit32);
            if (shift == 1)
                cpu.of(bit31 ^ bit32);</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;CL</args>
    <args size="8">Eb;Ib</args>
    <args size="16">Ew;I1</args>
    <args size="16">Ew;Ib</args>
    <args size="16">Ew;CL</args>
  </opcode>
  <opcode mnemonic="rcl">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; 0x1f;
            shift %= $size+1;
            long val = 0xffffffffL &amp; $op1.get;
            val |= cpu.cf() ? 1L &lt;&lt; $size : 0;
            val = (val &lt;&lt; shift) | (val &gt;&gt;&gt; ($size+1-shift));
            $op1.set$cast(int)val);
            boolean bit31 = (val &amp; (1L &lt;&lt; ($size-1))) != 0;
            boolean bit32 = (val &amp; (1L &lt;&lt; ($size))) != 0;
            cpu.cf(bit32);
            if (shift == 1)
                cpu.of(bit31 ^ bit32);</snippet>
    <args size="32">Ed;I1</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="rcr">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; 0x1f;
            shift %= $size+1;
            if (shift != 0)
            {
            long val = $mask$op1.get;
            val |= cpu.cf() ? 1L &lt;&lt; $size : 0;
            val = (val &gt;&gt;&gt; shift) | (val &lt;&lt; ($size+1-shift));
            $op1.set$cast(int)val);
            boolean bit30  = (val &amp;  (1L &lt;&lt; ($size-2))) != 0;
            boolean bit31 = (val &amp; (1L &lt;&lt; ($size-1))) != 0;
            cpu.cf((val &amp; (1L &lt;&lt; $size)) != 0);
            if (shift == 1)
                cpu.of(bit30 ^ bit31);
            }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;I1</args>
    <args size="16">Ew;CL</args>
  </opcode>
  <opcode mnemonic="rcr">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; 0x1f;
            if (shift != 0)
            {
            shift %= $size+1;
            long val = 0xffffffffL &amp; $op1.get;
            val |= cpu.cf() ? 1L &lt;&lt; $size : 0;
            val = (val &gt;&gt;&gt; shift) | (val &lt;&lt; ($size+1-shift));
            $op1.set$cast(int)val);
            boolean bit30  = (val &amp;  (1L &lt;&lt; ($size-2))) != 0;
            boolean bit31 = (val &amp; (1L &lt;&lt; ($size-1))) != 0;
            cpu.cf((val &amp; (1L &lt;&lt; $size)) != 0);
            if (shift == 1)
                cpu.of(bit30 ^ bit31);
            }</snippet>
    <args size="32">Ed;I1</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="rol">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; ($size-1);
            int reg0 = $mask$op1.get;
            int res = (reg0 &lt;&lt; shift) | (reg0 >>> ($size - shift));
            $op1.set$castres);
            boolean bit0  = (res &amp; 1 ) != 0;
            boolean bit31 = (res &amp; (1 &lt;&lt; ($size-1))) != 0;
            if ((0x1F &amp; $op2.get) > 0)
            {
                cpu.cf = bit0;
                cpu.of = bit0 ^ bit31;
                cpu.flagStatus &amp;= NOFCF;
            }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;I1</args>
    <args size="32">Ed;I1</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="ror">
    <return>Branch.None</return>
    <snippet>            int shift = $op2.get &amp; ($size-1);
            int reg0 = $mask1$op1.get;
            int res = (reg0 >>> shift) | (reg0 &lt;&lt; ($size - shift));
            $op1.set$castres);
            boolean bit30  = (res &amp; (1 &lt;&lt; ($size-2))) != 0;
            boolean bit31 = (res &amp; (1 &lt;&lt; ($size-1))) != 0;
            if (shift > 0)
            {
                cpu.cf = bit31;
                cpu.of = bit30 ^ bit31;
                cpu.flagStatus &amp;= NOFCF;
            }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;I1</args>
    <args size="32">Ed;I1</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="sar">
    <return>Branch.None</return>
    <snippet>        if($op2.get != 0)
        {
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = $op2.get;
            int res = $cast(cpu.flagOp1 &gt;&gt; cpu.flagOp2);
            $op1.set$castres);
            cpu.setOSZAPC_Logic$size(res);
            cpu.flagStatus |= CF;
            cpu.flagIns = UCodes.SAR$size;
        }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;I1</args>
    <args size="16">Ew;Ib</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;I1</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="sbb">
    <return>Branch.None</return>
    <snippet>        int add = (cpu.cf()? 1: 0);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - (cpu.flagOp2 + add));
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SBB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="8">AL;Ib</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;Gb</args>
    <args size="8">Gb;Eb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="32">Ed;Id</args>
    <args size="16">Ew;Iw</args>
    <args size="16">Ew;Gw</args>
    <args size="32">Ed;Gd</args>
    <args size="16">Gw;Ew</args>
    <args size="32">Gd;Ed</args>
  </opcode>

  <opcode mnemonic="sbb_o16">
    <return>Branch.None</return>
    <snippet>        int add = (cpu.cf()? 1: 0);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - (cpu.flagOp2 + add));
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SBB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="16">rAX;Iw</args>
  </opcode>

  <opcode mnemonic="sbb_o32">
    <return>Branch.None</return>
    <snippet>        int add = (cpu.cf()? 1: 0);
        cpu.flagOp1 = $op1.get;
        cpu.flagOp2 = $op2.get;
        cpu.flagResult = $cast(cpu.flagOp1 - (cpu.flagOp2 + add));
        $op1.set$castcpu.flagResult);
        cpu.flagIns = UCodes.SBB$size;
        cpu.flagStatus = OSZAPC;</snippet>
    <args size="32">rAX;Id</args>
  </opcode>

  <opcode mnemonic="shl">
    <return>Branch.None</return>
    <snippet>        int shift = $op2.get &amp; 0x1f;
        if(shift != 0)
        {
            if (shift &lt;= 16)
            {
                cpu.flagStatus = OSZPC;
            }
            else
            {
                cpu.flagStatus = SZP;
                cpu.of = false;
                cpu.cf = false;
            }
            cpu.af = false;
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = shift;
            cpu.flagResult = $cast(cpu.flagOp1 &lt;&lt; cpu.flagOp2);
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHL$size;
        }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;Gb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;I1</args>
    <args size="32">Ed;I1</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="shr">
    <return>Branch.None</return>
    <snippet>        if((0x1f &amp; $op2.get) != 0)
        {
            cpu.flagOp1 = $mask$op1.get;
            cpu.flagOp2 = 0x1f &amp; $op2.get;
            cpu.flagResult = $cast(cpu.flagOp1 &gt;&gt;&gt; cpu.flagOp2);
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHR$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="8">Eb;I1</args>
    <args size="8">Eb;Ib</args>
    <args size="8">Eb;CL</args>
    <args size="16">Ew;Gb</args>
    <args size="16">Ew;Ib</args>
    <args size="32">Ed;Ib</args>
    <args size="16">Ew;I1</args>
    <args size="32">Ed;I1</args>
    <args size="16">Ew;CL</args>
    <args size="32">Ed;CL</args>
  </opcode>

  <opcode mnemonic="shld">
    <return>Branch.None</return>
    <snippet>        if($op3.get != 0)
        {
            int shift = $op3.get &amp; 0x1f;
            if (shift &lt;= 16)
                cpu.flagOp1 = $op1.get;
            else
                cpu.flagOp1 = $op2.get;
            cpu.flagOp2 = shift;
            long rot = ((long)($mask$op1.get) &lt;&lt; (2*$size)) | ((0xffffffffL &amp; $mask$op2.get) &lt;&lt; $size) | ($mask$op1.get);
            cpu.flagResult = $cast((int)((rot &lt;&lt; shift) | (rot >>> (2*$size-shift))));
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHLD$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="16">Ew;Gw;Ib</args>
    <args size="16">Ew;Gw;CL</args>
  </opcode>
  <opcode mnemonic="shld">
    <return>Branch.None</return>
    <snippet>        if($op3.get != 0)
        {
            int shift = $op3.get &amp; 0x1f;
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = shift;
            long rot = ((0xffffffffL &amp;$op2.get) &lt;&lt; $size) | (0xffffffffL &amp;$op1.get);
            cpu.flagResult = $cast((int)((rot &lt;&lt; shift) | (rot >>> (2*$size-shift))));
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHLD$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="32">Ed;Gd;Ib</args>
    <args size="32">Ed;Gd;CL</args>
  </opcode>

  <opcode mnemonic="shrd">
    <return>Branch.None</return>
    <snippet>        if($op3.get != 0)
        {
            int shift = $op3.get &amp; 0x1f;
            if (shift &lt;= 16)
                cpu.flagOp1 = $op1.get;
            else
                cpu.flagOp1 = $op2.get;
            cpu.flagOp2 = shift;
            long rot = ((long)$op1.get &lt;&lt; (2*$size)) | (($mask$op2.get) &lt;&lt; $size) | ($mask$op1.get);
            cpu.flagResult = $cast((int)(rot >> shift));
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHRD$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="16">Ew;Gw;Ib</args>
    <args size="16">Ew;Gw;CL</args>
  </opcode>
  <opcode mnemonic="shrd">
    <return>Branch.None</return>
    <snippet>        if($op3.get != 0)
        {
            int shift = $op3.get &amp; 0x1f;
            cpu.flagOp1 = $op1.get;
            cpu.flagOp2 = shift;
            long rot = ((0xffffffffL &amp;$op2.get) &lt;&lt; $size) | (0xffffffffL &amp; $op1.get);
            cpu.flagResult = $cast((int)(rot >> shift));
            $op1.set$castcpu.flagResult);
            cpu.flagIns = UCodes.SHRD$size;
            cpu.flagStatus = OSZAPC;
        }</snippet>
    <args size="32">Ed;Gd;Ib</args>
    <args size="32">Ed;Gd;CL</args>
  </opcode>

  <opcode mnemonic="xlatb_a16" segment="true">
    <return>Branch.None</return>
    <snippet>        cpu.r_al.set8(seg.getByte((0xffff&amp;cpu.r_bx.get16()) + (0xff &amp; cpu.r_al.get8())));</snippet>
    <args size="0"></args>
  </opcode>

  <opcode mnemonic="xlatb_a32" segment="true">
    <return>Branch.None</return>
    <snippet>        cpu.r_al.set8(seg.getByte(cpu.r_ebx.get32() + (0xff &amp; cpu.r_al.get8())));</snippet>
    <args size="0"></args>
  </opcode>
</opcodesnippets>